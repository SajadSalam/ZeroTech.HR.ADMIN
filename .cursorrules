# ZeroTech HR Admin - Cursor Rules

## Project Overview
This is a Vue 3 + Nuxt 3 application for HR management with Arabic language support. The codebase follows specific patterns for CRUD operations, state management, and component structure.

## Core Architecture Patterns

### 1. Module Structure
Each feature module should follow this exact structure:
```
views/[module-name]/
├── components/
│   ├── [ModuleName]Create.vue
│   ├── [ModuleName]Edit.vue
│   └── [additional-components].vue
├── service/
│   └── index.ts
├── store/
│   └── index.ts
├── types/
│   └── index.ts
└── index.ts
```

### 2. Type Definitions Pattern
Always define types in this order:
```typescript
// Base entity type
export type EntityName = {
  name: string
  // other required fields
}

// DTO with BaseDto extension
export type EntityNameDto = BaseDto & EntityName & {
  // additional fields for API responses
}

// Create DTO
export type EntityNameCreateDto = EntityName & {
  // additional fields for creation
}

// Update DTO (if different from create)
export type EntityNameUpdateDto = EntityName & {
  id: number | string
}

// Filters extending BaseFilters
export type EntityNameFilters = BaseFilters & {
  // filter-specific fields
}
```

### 3. Service Layer Pattern
```typescript
interface IEntityService {
  get: (filters: EntityFilters) => Promise<PaginatedResponse<EntityDto>>
  create: (data: Entity) => Promise<EntityDto>
  update: (id: string | number, data: EntityUpdateDto) => Promise<EntityDto>
  delete: (id: string | number) => Promise<void>
}

export class EntityService implements IEntityService {
  // Implementation using axios from '~/services/app-client/axios'
}
```

### 4. Store Pattern (Pinia)
```typescript
export const useEntityStore = defineStore('entity', () => {
  // State
  const entities = ref<EntityDto[]>([])
  const isLoading = ref(false)
  const filters = ref<EntityFilters>({
    pageSize: 10,
    pageNumber: 1,
    // other default filters
  })
  const isCreateDialogOpen = ref(false)
  const isEditDialogOpen = ref(false)
  const selectedEntityId = ref<string | number | null>(null)
  const selectedEntity = ref<EntityDto | null>(null)
  const totalPages = ref(0)

  // Methods - NO PARAMETERS, use internal filters
  const getEntities = async () => {
    try {
      isLoading.value = true
      const response = await entityService.get(filters.value)
      entities.value = response.data
      totalPages.value = response.pagesCount
    } catch (error) {
      // Handle error
    } finally {
      isLoading.value = false
    }
  }

  // CRUD operations always call getEntities() after success
  const createEntity = async (data: Entity) => {
    try {
      isLoading.value = true
      await entityService.create(data)
      await getEntities()
    } catch (error) {
      throw error
    } finally {
      isLoading.value = false
    }
  }

  // Return all reactive properties and methods
  return {
    entities,
    isLoading,
    filters,
    getEntities,
    createEntity,
    updateEntity,
    deleteEntity,
    isCreateDialogOpen,
    isEditDialogOpen,
    selectedEntityId,
    selectedEntity,
    totalPages,
  }
})
```

### 5. Page Component Pattern
```vue
<script setup lang="ts">
import { useAppTableStore } from '~/components/app-table/stores/AppTableStore'
import AppTable from '~/components/app-table/AppTable.vue'
import { useEntityStore } from '~/views/entities/store'
import { tableHeader } from '~/views/entities'
import EntityCreate from '~/views/entities/components/EntityCreate.vue'
import AppCrudActions from '~/components/app-crud/components/AppCrudActions.vue'
import EntityEdit from '~/views/entities/components/EntityEdit.vue'
import type { EntityDto, EntityFilters } from '~/views/entities/types'
import { useAuthStore } from '~/views/auth/store/auth'

definePageMeta({
  title: 'Arabic Title',
  description: 'Arabic Description',
})

const entityStore = useEntityStore()
const appTableStore = useAppTableStore()
const isLoading = computed(() => entityStore.isLoading)
const entities = computed(() => entityStore.entities || [])
const filters = computed<EntityFilters>({
  get() {
    return entityStore.filters
  },
  set(value) {
    entityStore.filters = value
  },
})

const getEntities = async () => {
  appTableStore.setLoading(true)
  await entityStore.getEntities()
  appTableStore.setLoading(false)
}

getEntities()
watch(filters, () => { getEntities() }, { deep: true })

const { hasPrivilege } = useAuthStore()
</script>

<template>
  <div>
    <AppCrud
      add-button-text="Arabic Add Button Text"
      :add-btn-action="() => (entityStore.isCreateDialogOpen = true)"
      :pagination="true"
      :total-pages="entityStore.totalPages"
      title="Arabic Title"
      :hide-create="!hasPrivilege('permission:path')"
      @update:current-page="filters.pageNumber = $event"
    >
      <template #filters>
        <BaseInput v-model="filters.name" placeholder="Arabic Search" />
        <!-- Additional filters -->
      </template>
      <AppTable
        title="Arabic Table Title"
        :headers="tableHeader()"
        :items="entities"
        :is-loading="isLoading"
      >
        <template #data-actions="{ item }">
          <AppCrudActions
            :item="item"
            :hide-update="!hasPrivilege('update:permission')"
            :hide-delete="!hasPrivilege('delete:permission')"
            :edit-button-action="() => {
              entityStore.selectedEntity = item
              entityStore.selectedEntityId = item.id
              entityStore.isEditDialogOpen = true
            }"
            :delete-service="entityStore.deleteEntity"
          />
        </template>
      </AppTable>
    </AppCrud>
    <EntityCreate />
    <EntityEdit />
  </div>
</template>
```

### 6. Create/Edit Component Pattern
```vue
<script setup lang="ts">
import AppInputField from '~/components/app-field/AppInputField.vue'
import AppTextAreaField from '~/components/app-field/AppTextAreaField.vue'
import AppAutoCompleteField from '~/components/app-field/AppAutoCompleteField.vue'
import { requiredValidator } from '~/services/validation'
import { Validator } from '~/services/validator'
import { useEntityStore } from '../store'
import type { EntityCreateDto } from '../types'

const entityStore = useEntityStore()

const validator = new Validator<EntityCreateDto>(
  {
    // Default values
  },
  {
    // Validation rules with Arabic messages
    name: {
      required: requiredValidator('Arabic Field Name'),
    },
  }
)

const body = validator.validation
const isLoading = computed(() => entityStore.isLoading)

const createEntity = async () => {
  const isValid = await body.value.$validate()
  if (!isValid) return
  await entityStore.createEntity(validator.extractBody())
  validator.resetBody()
  entityStore.isCreateDialogOpen = false
}

watch(() => entityStore.isCreateDialogOpen, (val: boolean) => {
  if (val) validator.resetBody()
})
</script>

<template>
  <AppDialog
    v-model="entityStore.isCreateDialogOpen"
    title="Arabic Dialog Title"
    size="xl"
    overflow-y="visible"
  >
    <!-- Form fields with Arabic labels -->
    <template #actions>
      <BaseButton color="primary" class="gap-1" :loading="isLoading" @click="createEntity">
        <Icon name="ph:upload-simple-duotone" class="size-5" />
        Arabic Action Text
      </BaseButton>
    </template>
  </AppDialog>
</template>
```

## Language and Localization Rules

### 1. Arabic-First Approach
- **NEVER** use `$t()` or i18n functions
- All text should be directly in Arabic
- Use Arabic placeholders, labels, and messages
- Arabic text should be semantically correct and professional

### 2. Text Examples
```typescript
// Good
title="إنشاء قسم جديد"
placeholder="البحث في الأقسام"
label="اسم القسم"

// Bad
:title="$t('create-department')"
:placeholder="$t('search-departments')"
:label="$t('department-name')"
```

## Component Usage Rules

### 1. Form Fields
- Always use components from `~/components/app-field/`
- Use `AppInputField`, `AppTextAreaField`, `AppAutoCompleteField`
- Always include Arabic labels and proper validation

### 2. Tables and CRUD
- Always use `AppCrud` wrapper component
- Use `AppTable` for data display
- Use `AppCrudActions` for action buttons
- Template slots should use `#data-*` prefix

### 3. Validation
- Use `Validator` class from `~/services/validator`
- Use `requiredValidator` with Arabic messages
- Always validate before API calls

## API Integration Rules

### 1. Axios Usage
- Import from `~/services/app-client/axios`
- Always use proper TypeScript types for requests/responses
- Handle errors appropriately in try/catch blocks

### 2. Response Handling
- Expect `PaginatedResponse<T>` for list endpoints
- Update store state after successful operations
- Always call refresh methods after CRUD operations

## File Naming Conventions

### 1. Components
- PascalCase: `DepartmentCreate.vue`, `UserEdit.vue`
- Descriptive and action-oriented names

### 2. Files and Directories
- kebab-case for directories: `department-management/`
- camelCase for TypeScript files: `departmentService.ts`
- PascalCase for Vue components

## Import Organization

### 1. Import Order
```typescript
// 1. Vue/Nuxt imports
// 2. Component imports (alphabetical)
// 3. Service/Store imports
// 4. Type imports
// 5. Utility imports
```

### 2. Import Style
```typescript
// Good
import type { DepartmentDto, DepartmentFilters } from '~/views/departments/types'

// Bad
import { DepartmentDto, DepartmentFilters } from '~/views/departments/types'
```

## Error Handling Rules

### 1. Store Methods
- Always wrap in try/catch/finally
- Set loading states properly
- Log errors with descriptive messages
- Throw errors for UI handling when needed

### 2. Component Methods
- Handle validation before API calls
- Show appropriate user feedback
- Reset forms after successful operations

## Performance Rules

### 1. Computed Properties
- Use computed for derived state
- Prefer computed over methods for reactive data

### 2. Watchers
- Use deep watching for complex objects
- Clean up watchers when needed
- Avoid excessive API calls in watchers

## Security Rules

### 1. Privilege Checking
- Always check privileges using `hasPrivilege()`
- Hide UI elements based on permissions
- Use descriptive permission strings

### 2. Data Validation
- Validate on both client and expect server validation
- Sanitize user inputs
- Use proper TypeScript types for type safety

## Code Quality Rules

### 1. TypeScript
- Always use strict typing
- Avoid `any` type
- Use proper interfaces and types
- Export types separately from implementations

### 2. Vue Composition API
- Use `<script setup>` syntax
- Prefer composition over options API
- Use proper reactive references

### 3. Code Organization
- Keep components focused and single-purpose
- Extract reusable logic into composables
- Maintain consistent code structure across modules

## Testing Considerations
- Ensure components work with Arabic text (RTL)
- Test privilege-based access control
- Validate API integration with proper error handling
- Test form validation with Arabic error messages

## Documentation
- Comment complex business logic
- Document API integration patterns
- Maintain type definitions with proper JSDoc when needed
- Keep README updated with Arabic-specific considerations
